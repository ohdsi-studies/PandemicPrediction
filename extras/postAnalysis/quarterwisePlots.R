# Helpers to aggregate per-quarter bootstrap outputs and visualize model deltas.
# Relies on outputs generated by extras/postAnalysis/runQuarterwise().

`%||%` <- function(x, y) {
  if (is.null(x) || !length(x)) {
    y
  } else {
    x
  }
}

parseQuarterId <- function(quarterId) {
  # quarterId format: YYYYMMDD_YYYYMMDD_Outcomestring
  parts <- strsplit(as.character(quarterId), "_", fixed = TRUE)[[1]]
  if (length(parts) < 2) {
    return(list(
      start = NA,
      end = NA,
      mid = NA,
      label = quarterId,
      sortKey = NA_integer_
    ))
  }
  start <- as.Date(parts[1], "%Y%m%d")
  end <- as.Date(parts[2], "%Y%m%d")
  span <- if (is.na(start) || is.na(end)) NA_integer_ else as.integer(end - start)
  mid <- if (is.na(start) || is.na(span)) start else start + floor(span / 2)
  qNum <- if (is.na(start)) NA_integer_ else ((as.integer(format(start, "%m")) - 1L) %/% 3L) + 1L
  label <- if (is.na(qNum)) quarterId else sprintf("%s-Q%d", format(start, "%Y"), qNum)
  list(
    start = start,
    end = end,
    mid = mid,
    label = label,
    sortKey = if (is.na(start)) NA_integer_ else as.integer(start)
  )
}

collectQuarterwiseBootstrap <- function(
  resultsDir = "results/full",
  metrics = NULL,
  outcomes = NULL,
  featureSets = NULL,
  comparators = NULL,
  W = NULL,
  dropIncomplete = TRUE,
  verbose = FALSE
) {
  if (!dir.exists(resultsDir)) {
    stop("Directory not found: ", resultsDir)
  }
  files <- list.files(resultsDir, pattern = "\\.csv$", full.names = TRUE)
  if (!length(files)) {
    if (isTRUE(verbose)) message("No CSV files found in ", resultsDir)
    return(data.frame())
  }

  readOne <- function(path) {
    df <- tryCatch(
      utils::read.csv(path, stringsAsFactors = FALSE),
      error = function(e) {
        if (isTRUE(verbose)) {
          message("Skipping ", basename(path), ": ", conditionMessage(e))
        }
        NULL
      }
    )
    if (is.null(df) || !nrow(df)) return(NULL)
    if (!"quarterId" %in% names(df)) {
      if (isTRUE(verbose)) {
        message("Skipping ", basename(path), ": no quarterId column")
      }
      return(NULL)
    }
    info <- parseQuarterId(df$quarterId[1])
    df$quarterStart <- info$start
    df$quarterEnd <- info$end
    df$quarterMid <- info$mid
    df$quarterLabel <- info$label
    df$quarterSortKey <- info$sortKey
    df$sourceFile <- basename(path)
    # Derive outcome rate if counts are present
    if (all(c("N", "nEvents") %in% names(df))) {
      df$outcomeRate <- as.numeric(df$nEvents) / as.numeric(df$N)
    }
    df
  }

  dfs <- lapply(files, readOne)
  dfs <- Filter(Negate(is.null), dfs)
  if (!length(dfs)) {
    if (isTRUE(verbose)) message("No readable CSV files under ", resultsDir)
    return(data.frame())
  }
  out <- do.call(rbind, dfs)

  applyFilter <- function(data, column, values) {
    if (is.null(values) || !column %in% names(data)) return(data)
    if (!length(values)) return(data[0, , drop = FALSE])
    data[data[[column]] %in% values, , drop = FALSE]
  }

  out <- applyFilter(out, "metric", metrics)
  out <- applyFilter(out, "outcomeName", outcomes)
  out <- applyFilter(out, "featureSet", featureSets)
  out <- applyFilter(out, "comparator", comparators)
  out <- applyFilter(out, "W", W)

  if (!nrow(out)) return(out)

  if (isTRUE(dropIncomplete)) {
    keepCols <- intersect(c("delta", "lo", "hi"), names(out))
    if (length(keepCols)) {
      out <- out[stats::complete.cases(out[, keepCols, drop = FALSE]), , drop = FALSE]
    }
  }

  metricLevels <- c("AUROC", "AUPRC", "Brier", "ICI", "INB", "ANBC")
  out$metric <- factor(
    out$metric,
    levels = c(metricLevels, setdiff(unique(out$metric), metricLevels))
  )
  out$quarterStart <- as.Date(out$quarterStart, origin = "1970-01-01")
  out$quarterEnd <- as.Date(out$quarterEnd, origin = "1970-01-01")
  out$quarterMid <- as.Date(out$quarterMid, origin = "1970-01-01")
  out <- out[order(out$quarterStart, out$outcomeName, out$featureSet, out$W, out$comparator, out$metric), ]
  rownames(out) <- NULL
  out
}

plotQuarterwiseMetric <- function(
  results,
  metric = "AUROC",
  valueMode = c("delta", "absolute"),
  absoluteModelLabels = c(metricA = "Model A", metricB = "Model B"),
  absoluteCollapseModels = FALSE,
  colorBy = NULL,
  facetBy = c("outcomeName", "featureSet"),
  facetWrapCols = NULL,
  showIntervals = TRUE,
  showLines = TRUE,
  showPoints = TRUE,
  zeroLine = TRUE,
  showOutcomeRate = FALSE,
  outcomeRateColor = "#444444",
  outcomeRateLinetype = "dotdash",
  xAxisTextAngle = 45,
  xAxisTextHjust = 1,
  xAxisTextVjust = 1,
  intervalColumns = NULL,
  ciAlpha = 0.18,
  dateBreaks = "3 months",
  dateLabels = "%Y-%m",
  title = NULL,
  subtitle = NULL,
  yLabel = NULL
) {
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required for plotting.")
  }
  if (missing(results) || !nrow(results)) {
    stop("Input 'results' is empty; run collectQuarterwiseBootstrap() first.")
  }
  if (!metric %in% results$metric) {
    stop("Metric '", metric, "' not found in provided results.")
  }
  valueMode <- match.arg(valueMode)
  colorByMissing <- missing(colorBy) || is.null(colorBy)
  if (colorByMissing) {
    colorBy <- "comparator"
  }
  zeroLineSupplied <- !missing(zeroLine)
  df <- results[results$metric == metric, , drop = FALSE]
  if (!nrow(df)) {
    stop("No rows available for metric ", metric)
  }
  metricFilterTargets <- c("AUROC", "AUPRC")
  removeRecalComparators <- metric %in% metricFilterTargets
  if (removeRecalComparators && "comparator" %in% names(df)) {
    df <- df[!grepl("recal", tolower(df$comparator)), , drop = FALSE]
    if (!nrow(df)) {
      stop("No data remain after filtering recal comparators for metric ", metric)
    }
  }
  df <- df[order(df$quarterStart, df$comparator), ]
  facetVars <- facetBy[facetBy %in% names(df)]

  if (!"quarterStart" %in% names(df) || all(is.na(df$quarterStart))) {
    stop("quarterStart column missing; ensure collectQuarterwiseBootstrap ran successfully.")
  }
  if (!"quarterMid" %in% names(df) || all(is.na(df$quarterMid))) {
    df$quarterMid <- df$quarterStart
  }

  if (!zeroLineSupplied) {
    zeroLine <- identical(valueMode, "delta")
  }

  defaultIntervalCols <- list(
    delta = c("lo", "hi"),
    metricA = c("metricA_lo", "metricA_hi"),
    metricB = c("metricB_lo", "metricB_hi")
  )
  pickIntervalCols <- function(key) {
    if (is.null(intervalColumns)) return(defaultIntervalCols[[key]])
    if (is.list(intervalColumns)) {
      val <- intervalColumns[[key]]
      if (is.null(val)) return(defaultIntervalCols[[key]])
      return(val)
    }
    if (is.character(intervalColumns)) return(intervalColumns)
    defaultIntervalCols[[key]]
  }
  prettyModelKey <- function(keys) {
    if (is.null(keys)) return(keys)
    out <- keys
    mask <- !is.na(out) & nzchar(out)
    out[mask] <- gsub("_", " ", out[mask], fixed = TRUE)
    out
  }
  stripModelHorizon <- function(keys) {
    if (is.null(keys)) return(keys)
    out <- keys
    mask <- !is.na(out) & nzchar(out)
    out[mask] <- sub("_(6m|9m|12m(?:_[^_]+)?)$", "", out[mask], perl = TRUE)
    out
  }
  collapseAbsoluteSeries <- function(data) {
    if (!all(c("modelKey", "quarterId") %in% names(data))) return(data)
    valid <- !is.na(data$modelKey) & !is.na(data$quarterId)
    if (!any(valid)) return(data)
    keyParts <- list(data$modelKey[valid], data$quarterId[valid])
    if ("W" %in% names(data)) keyParts <- c(keyParts, data$W[valid])
    if ("featureSet" %in% names(data)) keyParts <- c(keyParts, data$featureSet[valid])
    key <- do.call(paste, c(keyParts, list(sep = "||")))
    if (!any(duplicated(key))) return(data)
    idxList <- split(which(valid), key)
    collapsed <- lapply(idxList, function(idx) {
      rows <- data[idx, , drop = FALSE]
      out <- rows[1, , drop = FALSE]
      numCols <- intersect(c("metricValue", "metricLo", "metricHi"), names(rows))
      if (length(idx) > 1 && length(numCols)) {
        for (col in numCols) {
          vals <- rows[[col]]
          if (is.null(vals)) next
          vals <- as.numeric(vals)
          if (all(is.na(vals))) next
          out[[col]] <- mean(vals, na.rm = TRUE)
        }
      }
      if (length(idx) > 1 && "comparator" %in% names(rows)) {
        comps <- unique(as.character(rows$comparator))
        comps <- comps[!is.na(comps) & nzchar(comps)]
        if (length(comps)) {
          out$comparator <- paste(comps, collapse = " | ")
        }
      }
      out
    })
    others <- data[!valid, , drop = FALSE]
    out <- do.call(rbind, c(collapsed, list(others)))
    rownames(out) <- NULL
    out
  }

  hasIntervals <- FALSE
  if (identical(valueMode, "delta")) {
    if (!"delta" %in% names(df)) {
      stop("Column 'delta' not present in results.")
    }
    df$metricValue <- df$delta
    df$modelLabel <- NA_character_
    cols <- pickIntervalCols("delta")
    if (length(cols) == 2 && all(cols %in% names(df))) {
      df$metricLo <- df[[cols[1]]]
      df$metricHi <- df[[cols[2]]]
      hasIntervals <- isTRUE(showIntervals)
    }
  } else {
    needed <- c("metricA", "metricB")
    missingCols <- setdiff(needed, names(df))
    if (length(missingCols)) {
      stop("Columns missing for absolute plotting: ", paste(missingCols, collapse = ", "))
    }
    roleDefaults <- c(A = "Model A", B = "Model B")
    roleAlias <- c(metricA = "A", metricB = "B", A = "A", B = "B")
    if (!is.null(absoluteModelLabels)) {
      if (is.null(names(absoluteModelLabels))) {
        stop("absoluteModelLabels must be a named vector; use names 'A', 'B', 'metricA', 'metricB', or model keys.")
      }
      aliasOverlap <- intersect(names(absoluteModelLabels), names(roleAlias))
      if (length(aliasOverlap)) {
        for (nm in aliasOverlap) {
          roleDefaults[roleAlias[[nm]]] <- absoluteModelLabels[[nm]]
        }
      }
    }
    makeSlice <- function(source, valueCol, roleName, keyCol) {
      slice <- source
      slice$modelRole <- roleName
      slice$modelKey <- if (keyCol %in% names(slice)) as.character(slice[[keyCol]]) else NA_character_
      slice$metricValue <- slice[[valueCol]]
      cols <- pickIntervalCols(valueCol)
      hasInt <- length(cols) == 2 && all(cols %in% names(slice))
      if (hasInt) {
        slice$metricLo <- slice[[cols[1]]]
        slice$metricHi <- slice[[cols[2]]]
      } else {
        slice$metricLo <- NA_real_
        slice$metricHi <- NA_real_
      }
      slice$.hasInterval <- hasInt
      slice
    }
    dfA <- makeSlice(df, "metricA", "A", "modelAKey")
    dfB <- makeSlice(df, "metricB", "B", "modelBKey")
    df <- rbind(dfA, dfB)
    df$modelLabel <- roleDefaults[df$modelRole]
    if (!is.null(absoluteModelLabels)) {
      keyMatches <- match(df$modelKey, names(absoluteModelLabels))
      mask <- !is.na(keyMatches)
      if (any(mask, na.rm = TRUE)) {
        df$modelLabel[mask] <- absoluteModelLabels[keyMatches[mask]]
      }
    }
    if ("modelKey" %in% names(df)) {
      fill <- is.na(df$modelLabel) | !nzchar(df$modelLabel) | df$modelLabel %in% roleDefaults
      df$modelLabel[fill & !is.na(df$modelKey)] <- prettyModelKey(df$modelKey[fill & !is.na(df$modelKey)])
    }
    hasIntervals <- isTRUE(showIntervals) && (any(dfA$.hasInterval) || any(dfB$.hasInterval))
    df$.hasInterval <- NULL
    if (isTRUE(absoluteCollapseModels)) {
      df <- collapseAbsoluteSeries(df)
    }
    if ("modelKey" %in% names(df)) {
      df$modelFamilyKey <- stripModelHorizon(df$modelKey)
      df$modelFamilyLabel <- df$modelFamilyKey
      fallback <- is.na(df$modelFamilyLabel) | !nzchar(df$modelFamilyLabel)
      df$modelFamilyLabel[fallback] <- df$modelKey[fallback]
      fallback <- is.na(df$modelFamilyLabel) | !nzchar(df$modelFamilyLabel)
      df$modelFamilyLabel[fallback] <- df$modelLabel[fallback]
      df$modelFamilyLabel <- prettyModelKey(df$modelFamilyLabel)
      if (!is.null(absoluteModelLabels)) {
        famMatches <- match(df$modelFamilyKey, names(absoluteModelLabels))
        famMask <- !is.na(famMatches)
        df$modelFamilyLabel[famMask] <- absoluteModelLabels[famMatches[famMask]]
      }
    }
  assignModelCategory <- function(data) {
    if (!all(c("modelRole", "featureSet") %in% names(data))) {
      return(rep(NA_character_, nrow(data)))
    }
    feature <- tolower(trimws(as.character(data$featureSet)))
    mkey <- if ("modelKey" %in% names(data)) tolower(as.character(data$modelKey)) else rep(NA_character_, nrow(data))
    out <- rep(NA_character_, nrow(data))
    isFull <- !is.na(feature) & feature == "full"
    isPars <- !is.na(feature) & grepl("pars", feature)
    isFrozen <- !is.na(mkey) & grepl("proxy_frozen", mkey)
    isRolling <- !is.na(mkey) & grepl("proxy_roll", mkey)
    isRecal <- !is.na(mkey) & grepl("proxy_recal", mkey)
    isCovid <- !is.na(mkey) & grepl("^covid", mkey)
    out[isCovid & isFull] <- "Covid Full"
    out[isCovid & isPars] <- "Covid Pars"
    out[isRolling & isFull] <- "Proxy Rolling Full"
    out[isRolling & isPars] <- "Proxy Rolling Pars"
    out[isFrozen & isFull] <- "Proxy Frozen Full"
    out[isFrozen & isPars] <- "Proxy Frozen Pars"
    out[isRecal & isFull] <- "Proxy Recal Full"
    out[isRecal & isPars] <- "Proxy Recal Pars"
    out
  }
    df$modelCategory <- assignModelCategory(df)
    if (removeRecalComparators) {
      targetCategories <- c("Covid Full", "Covid Pars", "Proxy Frozen Full", "Proxy Frozen Pars")
      df <- df[df$modelCategory %in% targetCategories, , drop = FALSE]
      if (!nrow(df)) {
        stop("No data remain after focusing on frozen proxy models for absolute plotting.")
      }
    }
    orderCols <- intersect(c("quarterStart", "quarterMid", "modelKey", "modelRole", "comparator"), names(df))
    if (length(orderCols)) {
      df <- df[do.call(order, c(df[orderCols], list(na.last = TRUE))), , drop = FALSE]
    }
  }

  if (identical(valueMode, "absolute") && colorByMissing) {
    preferredLabel <- if ("modelCategory" %in% names(df)) df$modelCategory else NA_character_
    fallbackLabel <- if ("modelFamilyLabel" %in% names(df)) df$modelFamilyLabel else if ("modelLabel" %in% names(df)) df$modelLabel else df$modelRole
    labelCol <- preferredLabel
    labelCol[is.na(labelCol) | !nzchar(labelCol)] <- fallbackLabel[is.na(labelCol) | !nzchar(labelCol)]
    if (!is.character(labelCol)) labelCol <- as.character(labelCol)
    labelCol[is.na(labelCol)] <- "Model"
    df$absoluteSeriesLabel <- labelCol
    colorBy <- "absoluteSeriesLabel"
    colorByMissing <- FALSE
  }

  if (colorBy %in% names(df)) {
    seriesCol <- df[[colorBy]]
  } else {
    seriesCol <- rep("All", nrow(df))
  }
  seriesCol <- as.character(seriesCol)
  seriesCol[is.na(seriesCol)] <- "Missing"
  baseCategoryLevels <- c("Covid Full", "Covid Pars", "Proxy Frozen Full", "Proxy Frozen Pars")
  if (identical(valueMode, "absolute") && identical(colorBy, "absoluteSeriesLabel")) {
    seriesLevels <- baseCategoryLevels
  } else {
    seriesLevels <- unique(seriesCol)
  }
  df$seriesLabel <- factor(seriesCol, levels = unique(c(seriesLevels, seriesCol)))
  df$seriesId <- as.character(df$seriesLabel)
  if (identical(valueMode, "absolute") && "modelKey" %in% names(df)) {
    validKey <- !is.na(df$modelKey) & nzchar(df$modelKey)
    df$seriesId[validKey] <- df$modelKey[validKey]
  }

  prepGroupValue <- function(values, tag) {
    if (inherits(values, "Date")) {
      values <- format(values, "%Y-%m-%d")
    } else if (!is.character(values)) {
      values <- as.character(values)
    }
    values[is.na(values)] <- paste("Missing", tag)
    values
  }
  groupCandidates <- c(
    "seriesId",
    "seriesLabel",
    "modelFamilyLabel",
    "modelLabel",
    "modelKey",
    "modelRole",
    "comparator",
    "outcomeName",
    "featureSet",
    "W",
    "modelAKey",
    "modelBKey"
  )
  groupColumns <- groupCandidates[groupCandidates %in% names(df)]
  if (length(groupColumns)) {
    groupValues <- lapply(groupColumns, function(col) prepGroupValue(df[[col]], col))
    df$seriesGroup <- do.call(
      interaction,
      c(groupValues, list(drop = TRUE, lex.order = TRUE))
    )
  } else {
    df$seriesGroup <- df$seriesLabel
  }

  if (is.null(yLabel)) {
    yLabel <- if (valueMode == "delta") paste("Delta", metric) else paste(metric, "value")
  }
  if (is.null(title)) {
    title <- if (valueMode == "delta") paste0("Quarter-wise ", metric, " delta") else paste0("Quarter-wise ", metric, " values")
  }

  if (length(facetVars) == 1) {
    df$facetWrap <- df[[facetVars[1]]]
  } else if (length(facetVars) >= 2) {
    df$facetRow <- df[[facetVars[1]]]
    df$facetCol <- df[[facetVars[2]]]
  }

  aesBase <- ggplot2::aes(x = quarterMid, y = metricValue, color = seriesLabel, group = seriesGroup)
  p <- ggplot2::ggplot(df, aesBase)
  if (isTRUE(zeroLine)) {
    p <- p + ggplot2::geom_hline(yintercept = 0, color = "#555555", linewidth = 0.4, linetype = "dashed")
  }
  if (hasIntervals) {
    p <- p + ggplot2::geom_ribbon(
      ggplot2::aes(ymin = metricLo, ymax = metricHi, fill = seriesLabel),
      alpha = ciAlpha,
      color = NA,
      linewidth = 0,
      inherit.aes = TRUE
    )
  }
  if (isTRUE(showLines)) {
    p <- p + ggplot2::geom_line(linewidth = 0.7)
  }
  if (isTRUE(showPoints)) {
    p <- p + ggplot2::geom_point(size = 1.8)
  }

  # Optional outcome rate overlay on a secondary axis (per quarter)
  if (isTRUE(showOutcomeRate) && "outcomeRate" %in% names(df)) {
    # Use one rate per quarter; if multiple rows share quarterMid, take first
    rateDf <- df[!duplicated(df$quarterMid), c("quarterMid", "outcomeRate")]
    rateDf <- rateDf[stats::complete.cases(rateDf$outcomeRate), , drop = FALSE]
    if (nrow(rateDf)) {
      yRange <- range(df$metricValue, na.rm = TRUE)
      rateRange <- range(rateDf$outcomeRate, na.rm = TRUE)
      if (diff(rateRange) == 0) {
        rateRange[2] <- rateRange[2] + 1e-6
      }
      if (diff(yRange) == 0) {
        yRange[2] <- yRange[2] + 1e-6
      }
      scaleToMetric <- function(r) {
        (r - rateRange[1]) / diff(rateRange) * diff(yRange) + yRange[1]
      }
      rateDf$rateScaled <- scaleToMetric(rateDf$outcomeRate)
      p <- p +
        ggplot2::geom_line(
          data = rateDf,
          ggplot2::aes(x = quarterMid, y = rateScaled),
          inherit.aes = FALSE,
          color = outcomeRateColor,
          linetype = outcomeRateLinetype,
          linewidth = 0.6
        ) +
        ggplot2::scale_y_continuous(
          name = yLabel,
          sec.axis = ggplot2::sec_axis(
            transform = ~ (.- yRange[1]) / diff(yRange) * diff(rateRange) + rateRange[1],
            name = "Outcome rate"
          )
        )
    }
  }

  p <- p +
    ggplot2::scale_x_date(date_breaks = dateBreaks, date_labels = dateLabels) +
    ggplot2::labs(
      title = title,
      subtitle = subtitle,
      x = "Quarter (midpoint)",
      y = yLabel,
      color = if (identical(colorBy, "absoluteSeriesLabel")) "Series" else gsub("_", " ", colorBy),
      fill = if (identical(colorBy, "absoluteSeriesLabel")) "Series" else gsub("_", " ", colorBy)
    )

  if (removeRecalComparators && identical(valueMode, "absolute") && identical(colorBy, "absoluteSeriesLabel")) {
    palette <- c(
      "Covid Full" = "#1f77b4",
      "Covid Pars" = "#6baed6",
      "Proxy Frozen Full" = "#ff7f0e",
      "Proxy Frozen Pars" = "#ffbb78"
    )
    palette <- palette[names(palette) %in% levels(df$seriesLabel)]
    if (length(palette)) {
    p <- p +
      ggplot2::scale_color_manual(values = palette, drop = TRUE, na.translate = FALSE) +
      ggplot2::scale_fill_manual(values = palette, drop = TRUE, na.translate = FALSE)
    }
  }

  if (length(facetVars) == 1 && "facetWrap" %in% names(df)) {
    p <- p + ggplot2::facet_wrap(~facetWrap, scales = "free_y", ncol = facetWrapCols)
  } else if (length(facetVars) >= 2 && all(c("facetRow", "facetCol") %in% names(df))) {
    p <- p + ggplot2::facet_grid(facetRow ~ facetCol, scales = "free_y")
  }

  p <- p + ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(
      legend.position = "bottom",
      panel.grid.minor = ggplot2::element_blank(),
      axis.text.x = ggplot2::element_text(
        angle = xAxisTextAngle,
        hjust = xAxisTextHjust,
        vjust = xAxisTextVjust
      )
    )
  p
}

plotQuarterwiseMetricFromDir <- function(
  resultsDir = "results/full",
  metric = "AUROC",
  outcomes = NULL,
  featureSets = NULL,
  comparators = NULL,
  W = NULL,
  ...
) {
  df <- collectQuarterwiseBootstrap(
    resultsDir = resultsDir,
    metrics = metric,
    outcomes = outcomes,
    featureSets = featureSets,
    comparators = comparators,
    W = W
  )
  if (!nrow(df)) {
    stop("No data found for plotting in ", resultsDir)
  }
  plotQuarterwiseMetric(df, metric = metric, ...)
}

# ---- Simple quarter-wise validation summaries (non-bootstrap) ----

collectQuarterwiseValidationStats <- function(
  runsRoot = file.path(
    "results",
    "runs",
    "rolling_recalibrated_validation",
    "strategusWork",
    "PatientLevelPredictionValidationModule",
    "OPTUM Extended DOD"
  ),
  metrics = c("AUROC", "AUPRC", "Eavg"),
  evalType = "Validation",
  outcomeNames = c(
    `11` = "Fatality",
    `14` = "Hospitalization",
    `13` = "RespiratoryFailure"
  )
) {
  files <- list.files(runsRoot, pattern = "runPlp\\.rds$", recursive = TRUE, full.names = TRUE)
  if (!length(files)) return(data.frame())

  readOne <- function(path) {
    dirPath <- dirname(path)
    vdPath <- file.path(dirPath, "model", "validationDetails.json")
    vd <- try(jsonlite::fromJSON(vdPath, simplifyVector = TRUE), silent = TRUE)
    if (inherits(vd, "try-error") || is.null(vd$restrictPlpDataSettings)) return(NULL)
    startDate <- vd$restrictPlpDataSettings$studyStartDate
    endDate <- vd$restrictPlpDataSettings$studyEndDate
    outcomeId <- vd$outcomeId
    outcomeName <- outcomeNames[as.character(outcomeId)] %||% NA_character_
    qid <- paste0(startDate, "_", endDate, "_", outcomeName %||% outcomeId)
    quarterStart <- as.Date(startDate, "%Y%m%d")
    quarterEnd <- as.Date(endDate, "%Y%m%d")
    quarterMid <- quarterStart + floor(as.integer(quarterEnd - quarterStart) / 2)

    run <- try(readRDS(path), silent = TRUE)
    if (inherits(run, "try-error")) return(NULL)
    es <- run$performanceEvaluation$evaluationStatistics
    if (is.null(es)) return(NULL)
    mask <- es$evaluation == evalType & es$metric %in% metrics
    if (!any(mask, na.rm = TRUE)) return(NULL)
    es <- es[mask, , drop = FALSE]
    data.frame(
      metric = es$metric,
      metricValue = suppressWarnings(as.numeric(es$value)),
      outcomeId = outcomeId,
      outcomeName = outcomeName,
      quarterId = qid,
      quarterStart = quarterStart,
      quarterEnd = quarterEnd,
      quarterMid = quarterMid,
      path = path,
      stringsAsFactors = FALSE
    )
  }

  dfs <- lapply(files, readOne)
  dfs <- Filter(Negate(is.null), dfs)
  if (!length(dfs)) return(data.frame())
  out <- do.call(rbind, dfs)
  out <- out[stats::complete.cases(out$metricValue), , drop = FALSE]
  out <- out[order(out$quarterStart, out$outcomeName, out$metric), ]
  rownames(out) <- NULL
  out
}

plotQuarterwiseValidation <- function(
  df,
  metric = "AUROC",
  colorBy = "outcomeName",
  dateBreaks = "3 months",
  dateLabels = "%Y-%m"
) {
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required for plotting.")
  }
  if (missing(df) || !nrow(df)) stop("Input df is empty.")
  if (!metric %in% df$metric) stop("Metric ", metric, " not found in df.")
  df <- df[df$metric == metric, , drop = FALSE]
  aesCol <- if (colorBy %in% names(df)) colorBy else NULL
  p <- ggplot2::ggplot(df, ggplot2::aes(x = quarterMid, y = metricValue, group = 1)) +
    ggplot2::geom_line() +
    ggplot2::geom_point()
  if (!is.null(aesCol)) {
    p <- ggplot2::ggplot(df, ggplot2::aes(x = quarterMid, y = metricValue, color = .data[[aesCol]], group = .data[[aesCol]])) +
      ggplot2::geom_line() +
      ggplot2::geom_point()
  }
  p <- p +
    ggplot2::scale_x_date(date_breaks = dateBreaks, date_labels = dateLabels) +
    ggplot2::labs(
      title = paste0("Quarter-wise ", metric, " (raw validation)"),
      x = "Quarter (midpoint)",
      y = metric,
      color = if (!is.null(aesCol)) aesCol else NULL
    ) +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(
      legend.position = "bottom",
      panel.grid.minor = ggplot2::element_blank()
    )
  p
}

# ---- Convert comparison rows to per-model rows for absolute plotting ----

comparisonToModelRows <- function(
  results,
  metric = "INB",
  labelMap = NULL
) {
  if (missing(results) || !nrow(results)) stop("results is empty")
  df <- results[results$metric == metric, , drop = FALSE]
  if (!nrow(df)) stop("No rows for metric ", metric)
  need <- c("metricA", "metricB", "modelAKey", "modelBKey")
  if (length(setdiff(need, names(df)))) {
    stop("Metric columns metricA/metricB or model keys missing.")
  }
  makeSlice <- function(side) {
    role <- if (side == "A") "A" else "B"
    keyCol <- if (side == "A") "modelAKey" else "modelBKey"
    valCol <- if (side == "A") "metricA" else "metricB"
    loCol <- paste0(valCol, "_lo")
    hiCol <- paste0(valCol, "_hi")
    out <- df
    out$modelKey <- out[[keyCol]]
    out$modelRole <- role
    out$metricValue <- out[[valCol]]
    out$metricLo <- if (loCol %in% names(out)) out[[loCol]] else NA_real_
    out$metricHi <- if (hiCol %in% names(out)) out[[hiCol]] else NA_real_
    out
  }
  a <- makeSlice("A")
  b <- makeSlice("B")
  res <- rbind(a, b)
  # keep only model-level columns
  keep <- intersect(
    c(
      "metric", "metricValue", "metricLo", "metricHi",
      "modelKey", "modelRole", "modelAKey", "modelBKey",
      "featureSet", "outcomeName", "quarterId",
      "quarterStart", "quarterEnd", "quarterMid", "comparator"
    ),
    names(res)
  )
  res <- res[, keep, drop = FALSE]

  # drop empty keys
  res <- res[!is.na(res$modelKey) & nzchar(res$modelKey), , drop = FALSE]

  res$seriesLabel <- res$modelKey
  if (!is.null(labelMap)) {
    idx <- match(res$modelKey, names(labelMap))
    res$seriesLabel[!is.na(idx)] <- labelMap[idx[!is.na(idx)]]
    # If labelMap supplied, keep only mapped models
    res <- res[res$modelKey %in% names(labelMap), , drop = FALSE]
  }
  # drop duplicate series per quarterId/modelKey
  res <- res[order(res$quarterStart, res$modelKey, res$modelRole), ]
  uniqIdx <- !duplicated(paste(res$quarterId, res$modelKey, sep = "||"))
  res <- res[uniqIdx, , drop = FALSE]
  rownames(res) <- NULL
  res
}

plotQuarterwiseModelMetric <- function(
  df,
  dateBreaks = "3 months",
  dateLabels = "%Y-%m",
  title = NULL,
  yLabel = NULL,
  showIntervals = TRUE
) {
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required for plotting.")
  }
  if (missing(df) || !nrow(df)) stop("df is empty; run comparisonToModelRows() first.")
  if (!"quarterMid" %in% names(df) || all(is.na(df$quarterMid))) {
    if ("quarterStart" %in% names(df)) {
      df$quarterMid <- df$quarterStart
    } else {
      stop("quarterMid/quarterStart missing.")
    }
  }
  if (is.null(yLabel)) yLabel <- "Metric value"
  aesBase <- ggplot2::aes(x = quarterMid, y = metricValue, color = seriesLabel, group = modelKey)
  p <- ggplot2::ggplot(df, aesBase)
  hasInt <- showIntervals && all(c("metricLo", "metricHi") %in% names(df))
  if (hasInt) {
    p <- p + ggplot2::geom_ribbon(
      ggplot2::aes(ymin = metricLo, ymax = metricHi, fill = seriesLabel),
      alpha = 0.18,
      color = NA,
      linewidth = 0,
      inherit.aes = TRUE
    )
  }
  p <- p +
    ggplot2::geom_line(linewidth = 0.7) +
    ggplot2::geom_point(size = 1.8) +
    ggplot2::scale_x_date(date_breaks = dateBreaks, date_labels = dateLabels) +
    ggplot2::labs(
      title = title %||% "Quarter-wise model metric",
      x = "Quarter (midpoint)",
      y = yLabel,
      color = "Model",
      fill = "Model"
    ) +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(
      legend.position = "bottom",
      panel.grid.minor = ggplot2::element_blank()
    )
  p
}

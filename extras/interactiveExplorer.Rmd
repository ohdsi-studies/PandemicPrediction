---
title: "Interactive Prediction Model Performance Explorer"
output: html_document
---

```{r setup, include=FALSE}
# ============================================================================
# SETUP AND DATA LOADING
# ============================================================================
# This chunk loads all necessary packages and the final results data.
# It is completely self-contained.

library(dplyr)
library(plotly)
library(crosstalk)
library(htmltools)
library(htmlwidgets)
library(ggthemes)
library(colorspace)
library(tidyr)
library(PandemicPrediction)

# --- Load the master results data frame ---
# Make sure you have saved your 'allResults' object to this file first.
# Example: saveRDS(allResults, "all_results.rds")
if (file.exists("all_results.rds")) {
  allResults <- readRDS("all_results.rds")
} else {
  allResults <- dplyr::bind_rows(
  getAnalysisResults(
    databasePath = "../results/development/databaseFile.sqlite",
    evaluationType = "Test",
    analysisId = "dev"
  ),
  getAnalysisResults(
    databasePath = "../results/validation/databaseFile.sqlite",
    evaluationType = "Validation",
    analysisId = "val_original"
  ),
  getAnalysisResults(
    databasePath = "../results/new-model-validation/databaseFile.sqlite",
    evaluationType = "Validation",
    analysisId = "val_new"
  )
)
}
unifiedResults <- allResults |>
  dplyr::mutate(
    plotStartDate = dplyr::if_else(analysisId == "dev", devStartDate, startDate),
    plotEndDate = dplyr::if_else(analysisId == "dev", devEndDate, endDate),
    lineType = dplyr::if_else(analysisId == "dev", "dash", "solid"),
    hoverText = dplyr::case_when(
      analysisId == "dev" ~ paste(
        "<b>Development Performance</b>",
        "<br><b>Model:</b>", legendLabel,
        "<br><b>AUROC:</b>", round(AUROC, 4),
        "<br><b>Dev Period:</b>", format(devStartDate, "%Y-%m-%d"), "to", format(devEndDate, "%Y-%m-%d")
      ),
      TRUE ~ paste(
        "<b>Validation Performance</b>",
        "<br><b>Model:</b>", legendLabel,
        "<br><b>AUROC:</b>", round(AUROC, 4),
        "<br><b>Validation Period:</b>", format(startDate, "%Y-%m-%d"), "to", format(endDate, "%Y-%m-%d"),
        "<br><b>Population:</b>", populationSize,
        "<br><b>Outcomes:</b>", outcomeCount
      )
    )
  )

unifiedResults <- unifiedResults |>
  dplyr::mutate(
    outcomeShort = substr(.data$outcomeName, 1, 1),
    featShort = substr(.data$featureSet, 1, 1),
    originShort = dplyr::case_when(
      .data$modelOrigin == "Original Influenza" ~ "Inf",
      .data$modelOrigin == "New Covid" ~ "Cov",
      TRUE ~ "Unk"
    ),
    devShort = dplyr::recode(
      .data$devPeriod,
      "First 3 Months" = "3m",
      "First 6 Months" = "6m",
      "First 9 Months" = "9m",
      "Full Year 2020 (Sampled)" = "FY-S",
      "Full Year 2020 (Full Pop.)" = "FY-FP",
      .default = NA_character_
    ),
    legendShort = dplyr::if_else(
      .data$modelOrigin == "New Covid",
      paste0(.data$outcomeShort, "-", .data$featShort, " ", .data$originShort, " ", .data$devShort),
      paste0(.data$outcomeShort, "-", .data$featShort, " ", .data$originShort)
    )
  )

# --- SharedData and plotting prep (match ggplot styling) ---
sharedAll <- SharedData$new(unifiedResults, ~fullName, group = "models")

# Expand non-Covid rows across all Covid dev-period levels so the devPeriod filter retains Influenza
devLevels <- unifiedResults |>
  dplyr::filter(.data$modelOrigin == "New Covid", !is.na(.data$devPeriod)) |>
  dplyr::distinct(.data$devPeriod) |>
  dplyr::pull(.data$devPeriod) |>
  as.character()

expand_by_dev <- function(df, devLevels) {
  inf <- df |> dplyr::filter(.data$modelOrigin != "New Covid")
  if (length(devLevels) > 0 && nrow(inf) > 0) {
    inf_exp <- tidyr::crossing(
      inf |> dplyr::select(-dplyr::any_of("devPeriod")),
      devPeriod = devLevels
    )
    dplyr::bind_rows(
      df |> dplyr::filter(.data$modelOrigin == "New Covid"),
      inf_exp
    )
  } else {
    df
  }
}

expandedUnified <- expand_by_dev(unifiedResults, devLevels)
devData <- expandedUnified |> dplyr::filter(.data$analysisId == "dev")
valData <- expandedUnified |> dplyr::filter(.data$analysisId != "dev")

# Build per-model palette with strong separation by origin
modelKey <- expandedUnified |>
  dplyr::distinct(fullName, modelOrigin)

influenzaModels <- modelKey |>
  dplyr::filter(.data$modelOrigin == "Original Influenza") |>
  dplyr::arrange(.data$fullName) |>
  dplyr::pull(.data$fullName)

covidModels <- modelKey |>
  dplyr::filter(.data$modelOrigin == "New Covid") |>
  dplyr::arrange(.data$fullName) |>
  dplyr::pull(.data$fullName)

# Order factor levels so the legend shows Influenza block then Covid block
allLevels <- c(influenzaModels, covidModels)
devData$fullName <- factor(devData$fullName, levels = allLevels)
valData$fullName <- factor(valData$fullName, levels = allLevels)

# Origin-specific qualitative palettes (colorblind-friendly)
palInf <- colorspace::qualitative_hcl(
  n = length(influenzaModels),
  h = c(195, 255),  # blue-cyan range
  c = 85,
  l = 55
)
palCov <- colorspace::qualitative_hcl(
  n = length(covidModels),
  h = c(350, 20),   # red-magenta range (wraps through 360)
  c = 85,
  l = 55
)

# Final model palette in the same order as allLevels
modelPalette <- c(palInf, palCov)

xRange <- dplyr::bind_rows(
  dplyr::select(valData, start = startDate, end = endDate),
  dplyr::select(devData, start = devStartDate, end = devEndDate)
) |>
  dplyr::summarise(
    xmin = min(start, na.rm = TRUE),
    xmax = max(end, na.rm = TRUE)
  ) |>
  dplyr::mutate(
    span = as.numeric(xmax - xmin),
    legendX = xmax - pmax(2, ceiling(0.02 * span))
  ) |>
  dplyr::slice(1)

# Add POSIXct columns for clean date formatting in tooltips
valData <- valData |>
  dplyr::mutate(
    startDateTime = as.POSIXct(.data$startDate),
    endDateTime = as.POSIXct(.data$endDate)
  )
devData <- devData |>
  dplyr::mutate(
    devStartDateTime = as.POSIXct(.data$devStartDate),
    devEndDateTime = as.POSIXct(.data$devEndDate)
  )

sharedAll <- SharedData$new(expandedUnified, ~fullName, group = "models")
sharedDev <- SharedData$new(devData, ~fullName, group = "models")
sharedVal <- SharedData$new(valData, ~fullName, group = "models")
```
<style>
  :root { --bg: #ffffff; --fg: #111111; --panel: #f7f7f7; --border: #dddddd; --link: #3a7bd5; }
  body.dark { --bg: #1e1e1e; --fg: #e2e2e2; --panel: #2a2a2a; --border: #444444; --link: #82b1ff; }
  body { background-color: var(--bg); color: var(--fg); }
  a { color: var(--link); }
  .container { display: flex; flex-direction: row; gap: 20px; }
  .filters { flex: 1; min-width: 200px; background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 10px; }
  .plot { flex: 4; }
  .theme-toggle { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 13px; }
  .theme-toggle input { transform: scale(1.1); }
  </style>
<div class="container">
<div class="filters">
```{r theme_toggle, echo=FALSE, results='asis'}
htmltools::HTML('<div class="theme-toggle"><label><input type="checkbox" id="darkModeToggle"> Dark mode</label></div><h4>Filters</h4>')
```
```{r filters, echo=FALSE}
# ============================================================================
# UI FILTER CONTROLS
# ============================================================================

# --- Create a Crosstalk "SharedData" object ---
# This is the magic that allows filters and plots to communicate.

# These create the interactive dropdowns and checkboxes.
div(
  style = "font-size: 14px;", # Smaller font for the filter panel
  filter_select(
    id = "outcome",
    label = "Select Outcome:",
    sharedData = sharedAll,
    group = ~outcomeName
  ),
  hr(), # Horizontal line for separation

  h4("Model Attributes"),
  filter_checkbox(
    id = "modelorigin",
    label = "Model Origin:",
    sharedData = sharedAll,
    group = ~modelOrigin,
    inline = FALSE # Stack the checkboxes vertically
  ),
  filter_checkbox(
    id = "featureset",
    label = "Feature Set:",
    sharedData = sharedAll,
    group = ~featureSet,
    inline = FALSE
  ),
  filter_checkbox(
    id = "devperiod",
    label = "Development Period:",
    sharedData = sharedAll,
    group = ~devPeriod,
    inline = FALSE
  )
)
```
</div>
<div class="plot">
```{r plot, echo=FALSE, message=FALSE, warning=FALSE}
# ============================================================================
# INTERACTIVE PLOT
# ============================================================================
# This code creates the main plot using plotly, linked to the filters.

# Prepare the two data layers: validation lines and development lines
# --- Create a Crosstalk "SharedData" object ---
# This is the magic that allows filters and plots to communicate.

# Create the plot
p <- plot_ly(source = "main_plot") |>
  # Validation segments (solid)
  add_segments(
    data = sharedVal,
    split = ~fullName, color = ~fullName, colors = modelPalette,
    x = ~startDate, xend = ~endDate,
    y = ~AUROC, yend = ~AUROC,
    name = ~legendShort,
    legendgroup = ~fullName,
    line = list(width = 1.2, dash = "solid"),
    text = ~paste0(
      "<b>", legendShort, "</b><br>",
      "AUROC: ", sprintf("%.3f", AUROC), "<br>",
      "Validation: ", format(startDateTime, "%Y-%m-%d"), " \u2192 ", format(endDateTime, "%Y-%m-%d"), "<br>",
      "N: ", format(populationSize, big.mark = ",", scientific = FALSE),
      "  |  Outcomes: ", format(outcomeCount, big.mark = ",", scientific = FALSE)
    ),
    hovertemplate = "%{text}<extra></extra>",
    showlegend = TRUE
  ) |>
  # Development segments (dashed)
  add_segments(
    data = sharedDev,
    split = ~fullName, color = ~fullName, colors = modelPalette,
    x = ~devStartDate, xend = ~devEndDate,
    y = ~AUROC, yend = ~AUROC,
    name = ~legendShort,
    legendgroup = ~fullName,
    line = list(width = 1.2, dash = "dash"),
    text = ~paste0(
      "<b>", legendShort, "</b><br>",
      "AUROC: ", sprintf("%.3f", AUROC), "<br>",
      "Development: ", format(devStartDateTime, "%Y-%m-%d"), " \u2192 ", format(devEndDateTime, "%Y-%m-%d")
    ),
    hovertemplate = "%{text}<extra></extra>",
    showlegend = FALSE
  ) |>
  # Validation markers at segment ends
  add_markers(
    data = sharedVal,
    split = ~fullName, color = ~fullName, colors = modelPalette,
    x = ~startDate, y = ~AUROC,
    legendgroup = ~fullName,
    showlegend = FALSE, hoverinfo = "none"
  ) |>
  add_markers(
    data = sharedVal,
    split = ~fullName, color = ~fullName, colors = modelPalette,
    x = ~endDate, y = ~AUROC,
    legendgroup = ~fullName,
    showlegend = FALSE, hoverinfo = "none"
  ) |>
  layout(
    title = "Interactive Model Performance Explorer",
    xaxis = list(
      title = "Validation Period",
      type = "date",
      range = c(xRange$xmin, xRange$xmax),
      tickformat = "%b %Y",
      dtick = "M3",
      tickangle = 45,
      rangeslider = list(visible = TRUE),
      showspikes = TRUE,
      spikemode = "across",
      spikesnap = "cursor",
      spikecolor = "rgba(0,0,0,0.25)",
      spikethickness = 1
    ),
    yaxis = list(title = "AUROC", range = c(0.5, 1)),
    hovermode = "x unified",
    hoverlabel = list(font = list(size = 11)),
    showlegend = TRUE,
    legend = list(
      orientation = "v",
      x = 1.02, xanchor = "left",
      y = 1, yanchor = "top",
      font = list(size = 11),
      itemsizing = "constant",
      itemwidth = 20,
      itemclick = "toggleothers",
      itemdoubleclick = "toggle"
    ),
    margin = list(t = 60, r = 180, b = 100, l = 60)
  )

p <- htmlwidgets::onRender(p, "
  function(el, x) {
    function applyTheme(dark) {
      document.body.classList.toggle('dark', dark);
      var layoutUpdate = dark ? {
        template: 'plotly_dark',
        paper_bgcolor: '#1e1e1e',
        plot_bgcolor: '#1e1e1e',
        font: {color: '#e2e2e2'},
        xaxis: {gridcolor: '#444', zerolinecolor: '#444'},
        yaxis: {gridcolor: '#444', zerolinecolor: '#444'},
        legend: {bgcolor: 'rgba(30,30,30,0.85)', bordercolor: '#555', borderwidth: 1}
      } : {
        template: 'plotly_white',
        paper_bgcolor: '#ffffff',
        plot_bgcolor: '#ffffff',
        font: {color: '#222'},
        xaxis: {gridcolor: '#e5e5e5', zerolinecolor: '#e5e5e5'},
        yaxis: {gridcolor: '#e5e5e5', zerolinecolor: '#e5e5e5'},
        legend: {bgcolor: 'rgba(255,255,255,0.85)', bordercolor: '#ddd', borderwidth: 1}
      };
      Plotly.relayout(el, layoutUpdate);
    }
    var toggle = document.getElementById('darkModeToggle');
    var mql = window.matchMedia('(prefers-color-scheme: dark)');
    // Initialize from OS preference unless user already toggled
    if (toggle && !toggle.hasAttribute('data-initialized')) {
      toggle.checked = mql.matches;
      toggle.setAttribute('data-initialized','1');
    }
    var startDark = toggle ? toggle.checked : mql.matches;
    applyTheme(startDark);
    if (toggle) {
      toggle.addEventListener('change', function(e){ applyTheme(e.target.checked); });
    }
  }
  ")

# Print the final plot
p
```  
</div>
</div>
